HOW TO INSTALL ZIP

     Zip is distributed as C source code that can be compiled on a
     wide range of systems: Unix, VMS, MSDOS, OS/2, NT, Amiga, Atari,
     BeOS, VM/CMS, ...  You will need Unzip 5.0p1 (under any system) or
     PKUNZIP 2.04g or later (under MSDOS) to unpack the distribution
     file, zip23.zip. But since you read this, you have unpacked it
     already, or you cheated and got a tar.Z file...

Installation on Unix

     Let's assume that you start from scratch and have not yet
     unpacked the sources. First, unpack the source as follows,
     assuming that you have zip23.zip in the current directory.

          mkdir zipsrc
          cd zipsrc
          unzip ../zip23

     This extracts all source files and documentation in the
     directory called "zipsrc". If you wish to build a version
     of zip with encryption capabilities, you must also get the
     separate package zcrypt28.zip and overwrite the dummy files
     crypt.c and crypt.h.

     You then do:

          make -f unix/Makefile system

     where "system" is one of: generic, generic_gcc,
     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.

     Try "make -f unix/Makefile generic" first, this works on many systems.
     If this fails, then use one of the special targets given above.

     Among other special systems are Cray Unicos, Zilog Zeus and MINIX.

     If you get error messages "constant expected" in deflate.c, add
     -DDYN_ALLOC to CFLAGS in your makefile entry.

     If you have lots of memory, try compiling with -DBIG_MEM. If your
     system supports mmap(), try compiling with -DMMAP. This generally
     gives faster compression but uses more memory. See the unix/Makefile
     entry mmap_gcc for an example.

     If none of these compiles, links, and functions properly on
     your Unix system, see the file README for how to get help.

     If the appropriate system was selected, then the executables
     zip, zipnote and zipsplit will be created.  You can copy them
     to an appropriate directory in the search path using:

          make -f unix/Makefile install

     The defaults are /usr/local/bin for the executables and
     /usr/local/man/man1 for the manual page. Change the macros
     BINDIR and MANDIR in makefile if appropriate.

     You can use the command "set" to see the current search
     path.  If you are using the C-Shell (csh), enter the com-
     mand:

          rehash

     so csh can find the new command in the path.  You are now
     ready to use Zip.

     You can get rid of the now unnecessary source and object
     files with:

          cd ..
          rm -r zipsrc

     This will remove the directory zip and its contents created
     by unzip.  You should keep the zip20.zip file around though,
     in case you need to build it again or want to give it to a
     colleague.

     You can add the following lines to the file /etc/magic for
     usage by the 'file' command:

0       string          PK              Zip archive
>4      byte            011             (at least v0.9 to extract)
>4      byte            012             (at least v1.0 to extract)
>4      byte            013             (at least v1.1 to extract)
>4      byte            024             (at least v2.0 to extract)
>4      byte            025             (at least v2.1 to extract)


Installation on other systems

     The steps for installation under VMS, MSDOS, OS/2, NT, Amiga and
     Atari are similar to the above: first unzip the distribution
     files into their own directory. The system-dependent files are
     stored in special subdirectories.

     For all the non-unix ports which support the creation of "UT" extra
     fields (these ports contain USE_EF_UT_TIME in the list of optional
     features displayed with "zip -v"), the timezone environment variable TZ
     should be set according to the local timezone in order for the -f,
     -u and -o options to work correctly.

  MSDOS:

     Do one of:

          make msdos\makefile.msc               (Microsoft C 5.1)
          nmake -f msdos\makefile.msc           (Microsoft C 6.0 and newer)
          make -fmsdos\makefile.bor -DCC_REV=1  (Borland Turbo C++ 1.0)
          make -fmsdos\makefile.bor             (Borland C++ 2.0 and newer)
          make -fmsdos\makefile.tc              (Borland Turbo C 2.0)
          make -f msdos/makefile.dj1            (DJGPP v1.12m4)
          make -f msdos/makefile.dj2            (DJGPP v2.01 and newer)
          make -f msdos/makefile.emx            (gcc/emx 0.9b and newer)
          make -f os2/makefile.os2 gccdos       (gcc/emx 0.9b and newer)
          wmake -f msdos\makefile.wat           (Watcom C 11.x 16-bit)
          wmake -f msdos\makefile.wat PM=1      (Watcom C 11.x 32-bit, PMODE/W)


     for Microsoft, Borland C++ and Turbo C, Watcom C/C++ and the various
     free GNU C implementations, respectively. More detailed instructions
     can be found in the respective makefiles.


  WIN32 (Windows NT and Windows 95):

     Supported compilers are Microsoft Visual C++, Watcom C/C++ and
     the free GNU C implementation gcc/emx+rsxnt. The makefiles supplied
     in the win32/ subdirectory contain further information.


  Windows DLL (Windows 3.1 16-bit and WIN32):

     Supported environments are Visual C++ 5.x (32-bit only) and
     Borland C++ (4.52, and newer). For instructions how to build
     the DLLs and where find the makefiles, look into windll/contents.


  OS/2:

     Type

          {make} -f os2/makefile.os2

     to get a list of supported targets/compiling environments.
     (replace "{make}" with the name of your OS/2 make utility.)

     To initiate the actual compiling process, you have to specify
     a system target:

          {make} -f os2/makefile.os2 {system}

     An example: type

          nmake -f os2/makefile.os2 msc

     for Microsoft C 6.00.


  VMS (OpenVMS):

     On VMS, two build methods are provided: a command procedure, and
     description files for MMS or MMK.  Both methods must be run from
     the main directory, not the [.VMS] subdirectory.

     A simple build using the command procedure looks like this:
          @ [.VMS]BUILD_ZIP.COM

     A simple build using MMS or MMK looks like this:
          MMS /DESCRIP = [.VMS]DESCRIP.MMS      ! Or, with MMK, ...
          MMK /DESCRIP = [.VMS]DESCRIP.MMS

     Various options for each build method are explained in comments in
     the main builder file, either BUILD_ZIP.COM or DESCRIP.MMS.

     Here are some more complex build examples:

     o Build with the large-file option enabled (non-VAX only):

          @ [.VMS]BUILD_ZIP LARGE
       or:
          MMS /DESC = [.VMS] /MACRO = LARGE=1

     o Re-link the executables (small-file and large-file):

          @ [.VMS]BUILD_ZIP LINK
          @ [.VMS]BUILD_ZIP LARGE LINK
       or
          MMK /DESC = [.VMS] CLEAN_EXE  ! Deletes existing executables.
          MMK /DESC = [.VMS]            ! Builds new executables.
          MMK /DESC = [.VMS] /MACRO = LARGE=1 CLEAN_EXE
          MMK /DESC = [.VMS] /MACRO = LARGE=1 

     o Build a large-file product from scratch, for debug, getting
       compiler listings and link maps:

          mms /desc = [.vms] clean
          mms /desc = [.vms] /macro = (DBG=1, LARGE=1. LIST=1)

     On VAX, the builders attempt to cope with the various available C
     compilers: DEC/Compaq/HP C, VAX C, or GNU C.  If DEC/Compaq/HP C is
     not available or not desired, comments in the relevant builder file
     explain the command-line options used to select a different
     compiler.

     System-architecture-specific files (like objects and executables)
     are placed in separate directories, such as [.ALPHA], [.IA64], or
     [.VAX].  Large-file products get their own directories, [.ALPHAL]
     or [.IA64L].  On VAX, VAX C products are placed in [.VAXV], GNU C
     products in [.VAXG].  Selecting the IM scheme for VMS/RMS attribute
     storage adds an "I" to the destination directory name ([.ALPHAIL],
     [.IA64I], [.VAXVI], and so on).  Each product builder announces
     what the destination directory will be when it is run.

     Common files, such as the help libraries (ZIP.HLP for the default
     UNIX-like command-line interface, ZIP_CLI.HLP for the VMS-like
     command-line interface), are placed in the main directory.  With a
     mixed-architecture VMS cluster, the same main directory on a shared
     disk may may be used by all system types.  (Using the NOHELP option
     with BUILD_ZIP.COM can keep it from making the same help files
     repeatedly.)

     To complete the installation, the executables may be left in place,
     or moved (or copied) to a convenient place.  It's then common to
     define symbols to make the Zip executables foreign commands, often
     in SYS$MANAGER:SYLOGIN.COM, or individual users'
     SYS$LOGIN:LOGIN.COM.  Typical commands might look like these:

          $ ZIP :== $ device:[directory]ZIP.EXE
          $ ZIP_CLI :== $ device:[directory]ZIP_CLI.EXE
          $ ZIPCLOAK :== $ device:[directory]ZIPCLOAK.EXE
          $ ZIPNOTE :== $ device:[directory]ZIPNOTE.EXE
          $ ZIPSPLIT :== $ device:[directory]ZIPSPLIT.EXE

     If the CLI form of the Zip executable were preferred, one might
     use commands like these, instead, for the Zip programs:

          $ ZIP :== $ device:[directory]ZIP_CLI.EXE
          $ ZIP_UNIX :== $ device:[directory]ZIP.EXE

     Alternatively, on systems which support it, a user may define the
     logical name DCL$PATH to include the device:[directory] where the
     Zip executables are stored.  (If this is done, the command name
     will be the same as the program name.)  The "OpenVMS User's Manual"
     describes these mechanisms in more detail.

     The builders create help text files, ZIP.HLP and ZIP_CLI.HLP. 
     These may be incorporated into an existing help library, or a
     separate Zip help library may be created using commands like these,
     using either ZIP.HLP (as shown) or ZIP_CLI.HLP:

          $ LIBRARY /HELP dev:[dir]existing_library.HLB ZIP.HLP

          $ LIBRARY /CREATE /HELP ZIP.HLB ZIP.HLP

     Zip help may then be accessed from a separate Zip help library
     using a command like:

          $ HELP /LIBRARY = device:[directory]ZIP.HLB

     For greater ease, the user (or system manager) may define a
     HLP$LIBRARY logical name to allow the HELP utility to find the Zip
     help library automatically.  See HELP HELP /USERLIBRARY for more
     details.   The command procedure HLP_LIB_NEXT.COM may be used to
     determine the next available HLP$LIBRARY logical name, and could be
     adapted to define a HLP$LIBRARY logical name for a Zip help
     library.

     Some further information may be found in the files
     [.VMS]00README.TXT and [.VMS]00BINARY.VMS, though much of what's
     there is now obsolete.

For command help on any of the zip* utilities, simply enter
the name with no arguments.
