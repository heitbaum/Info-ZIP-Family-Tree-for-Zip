HOW TO INSTALL ZIP

     Zip is distributed as C source code that can be compiled on a
     wide range of systems: Unix, VMS, MSDOS, OS/2, NT, Amiga, Atari,
     BeOS, VM/CMS, ...  You will need Unzip 5.0p1 (under any system) or
     PKUNZIP 2.04g or later (under MSDOS) to unpack the distribution
     file, zip30.zip. But since you read this, you have unpacked it
     already, or you cheated and got a tar.Z file...

Installation on Unix

     Let's assume that you start from scratch and have not yet
     unpacked the sources. First, unpack the source as follows,
     assuming that you have zip30.zip in the current directory.

          mkdir zipsrc
          cd zipsrc
          unzip ../zip30

     This extracts all source files and documentation in the
     directory called "zipsrc". This release now includes the standard
     encryption code previously in the separate package zcrypt29.zip,
     but you still can decide wether to activate the crypt code or not.
     Crypt is enabled by default, but you may disable it by specifying
     the option -DNO_CRYPT in the LOCAL_ZIP environment variable (or by
     adding this option to the compilation options in the appropiate
     makefile).
     See Readme.cr for more on crypt.

     You then do:

          make -f unix/Makefile system

     where "system" is one of: generic, generic_gcc,
     att6300, coherent, cray_v3, minix, sco_x286, xenix, zilog.

     Try "make -f unix/Makefile generic" first, this works on many systems.
     If this fails, then use one of the special targets given above.

     Among other special systems are Cray Unicos, Zilog Zeus and MINIX.

     If you get error messages "constant expected" in deflate.c, add
     -DDYN_ALLOC to CFLAGS in your makefile entry.

     If you have lots of memory, try compiling with -DBIG_MEM. If your
     system supports mmap(), try compiling with -DMMAP. This generally
     gives faster compression but uses more memory. See the unix/Makefile
     entry mmap_gcc for an example.

     If none of these compiles, links, and functions properly on
     your Unix system, see the file README for how to get help.

     If the appropriate system was selected, then the executables
     zip, zipnote and zipsplit will be created.  You can copy them
     to an appropriate directory in the search path using:

          make -f unix/Makefile install

     The defaults are /usr/local/bin for the executables and
     /usr/local/man/man1 for the manual page. Change the macros
     BINDIR and MANDIR in makefile if appropriate.

     You can use the command "set" to see the current search
     path.  If you are using the C-Shell (csh), enter the com-
     mand:

          rehash

     so csh can find the new command in the path.  You are now
     ready to use Zip.

     You can get rid of the now unnecessary source and object
     files with:

          cd ..
          rm -r zipsrc

     This will remove the directory zip and its contents created
     by unzip.  You should keep the zip30.zip file around though,
     in case you need to build it again or want to give it to a
     colleague.

     You can add the following lines to the file /etc/magic for
     usage by the 'file' command:

0       string          PK              Zip archive
>4      byte            011             (at least v0.9 to extract)
>4      byte            012             (at least v1.0 to extract)
>4      byte            013             (at least v1.1 to extract)
>4      byte            024             (at least v2.0 to extract)
>4      byte            025             (at least v2.1 to extract)


Installation on other systems

     The steps for installation under VMS, MSDOS, OS/2, NT, Amiga and
     Atari are similar to the above: first unzip the distribution
     files into their own directory.  The system-dependent files are
     stored in special subdirectories.

     For all the non-unix ports which support the creation of "UT" extra
     fields (these ports contain USE_EF_UT_TIME in the list of optional
     features displayed with "zip -v"), the timezone environment variable TZ
     should be set according to the local timezone in order for the -f,
     -u and -o options to work correctly.  This is not needed for the WIN32
     and WinDLL ports, since they get the timezone information from the OS by
     other means.

  MSDOS:

     Do one of:

          make msdos\makefile.msc               (Microsoft C 5.1)
          nmake -f msdos\makefile.msc           (Microsoft C 6.0 and newer)
          make -fmsdos\makefile.bor -DCC_REV=1  (Borland Turbo C++ 1.0)
          make -fmsdos\makefile.bor             (Borland C++ 2.0 and newer)
          make -fmsdos\makefile.tc              (Borland Turbo C 2.0x)
          make -f msdos/makefile.dj1            (DJGPP v1.12m4)
          make -f msdos/makefile.dj2            (DJGPP v2.01 and newer)
          make -f msdos/makefile.emx            (gcc/emx 0.9b and newer)
          make -f os2/makefile.os2 gccdos       (gcc/emx 0.9b and newer)
          wmake -f msdos\makefile.wat           (Watcom C 11.x 16-bit)
          wmake -f msdos\makefile.wat PM=1      (Watcom C 11.x 32-bit, PMODE/W)


     for Microsoft, Borland C++ and Turbo C, Watcom C/C++ and the various
     free GNU C implementations, respectively. More detailed instructions
     can be found in the respective makefiles.


  WIN32 (Windows NT/2K/XP/2K3 and Windows 95/98/ME):

     Supported compilers are Microsoft Visual C++, Borland C++, Watcom C/C++,
     and miscellaneous free GNU C implementations (gcc/mingw, CygWin, ...).
     The makefiles supplied in the win32/ subdirectory contain further
     information.


  Windows DLL (WIN32):

     Supported environments are Visual C++ (32-bit only, 5.x and newer).
     For instructions how to build the DLLs and where find the makefiles,
     look into windll/contents.


  OS/2:

     Type

          {make} -f os2/makefile.os2

     to get a list of supported targets/compiling environments.
     (replace "{make}" with the name of your OS/2 make utility.)

     To initiate the actual compiling process, you have to specify
     a system target:

          {make} -f os2/makefile.os2 {system}

     An example: type

          nmake -f os2/makefile.os2 msc

     for Microsoft C 6.00.


  VMS (OpenVMS):

     On VMS, two build methods are provided: a command procedure, and
     description files for MMS or MMK.  Both methods must be run from
     the main directory, not the [.VMS] subdirectory.

     A simple build using the command procedure looks like this:
          @ [.VMS]BUILD_ZIP.COM

     A simple build using MMS or MMK looks like this:
          MMS /DESCRIP = [.VMS]DESCRIP.MMS      ! Or, with MMK, ...
          MMK /DESCRIP = [.VMS]DESCRIP.MMS

     Various options for each build method are explained in comments in
     the main builder file, either BUILD_ZIP.COM or DESCRIP.MMS.

     Here are some more complex build examples:

     o Build with the large-file option enabled (non-VAX only):

          @ [.VMS]BUILD_ZIP LARGE
       or:
          MMS /DESC = [.VMS] /MACRO = LARGE=1

     o Re-link the executables (small-file and large-file):

          @ [.VMS]BUILD_ZIP LINK
          @ [.VMS]BUILD_ZIP LARGE LINK
       or
          MMK /DESC = [.VMS] CLEAN_EXE  ! Deletes existing executables.
          MMK /DESC = [.VMS]            ! Builds new executables.
          MMK /DESC = [.VMS] /MACRO = LARGE=1 CLEAN_EXE
          MMK /DESC = [.VMS] /MACRO = LARGE=1

     o Build a large-file product from scratch, for debug, getting
       compiler listings and link maps:

          mms /desc = [.vms] clean
          mms /desc = [.vms] /macro = (DBG=1, LARGE=1. LIST=1)

     On VAX, the builders attempt to cope with the various available C
     compilers: DEC/Compaq/HP C, VAX C, or GNU C.  If DEC/Compaq/HP C is
     not available or not desired, comments in the relevant builder file
     explain the command-line options used to select a different
     compiler.

     System-architecture-specific files (like objects and executables)
     are placed in separate directories, such as [.ALPHA], [.IA64], or
     [.VAX].  Large-file products get their own directories, [.ALPHAL]
     or [.IA64L].  On VAX, VAX C products are placed in [.VAXV], GNU C
     products in [.VAXG].  (If the old "IM" scheme for storing VMS/RMS
     file attributes is requested, an "I" is added to the destination
     directory name, for example, [.ALPHAIL], [.VAXI], [.VAXIV], and so
     on.)  Each product builder announces what the destination directory
     will be when it is run.

     Common files, such as the help libraries (ZIP.HLP for the default
     UNIX-like command-line interface, ZIP_CLI.HLP for the VMS-like
     command-line interface), are placed in the main directory.  With a
     mixed-architecture VMS cluster, the same main directory on a shared
     disk may may be used by all system types.  (Using the NOHELP option
     with BUILD_ZIP.COM can keep it from making the same help files
     repeatedly.)

     Some further information may be found in the files
     [.VMS]00README. and [.VMS]00BINARY.VMS, though much of what's
     there is now obsolete.

     While other methods (like DCL$PATH) exist, most users define
     symbols to use Zip as a foreign command, often in the user's
     SYS$LOGIN:LOGIN.COM, or in a more central location, like
     SYS$MANAGER:SYLOGIN.COM.  A typical symbol definition might look
     like this:

        zip :== $ dev:[dir]zip.exe      ! UNIX-like command line.
     or:
        zip :== $ dev:[dir]zip_cli.exe  ! VMS-like command line.

     On a non-VAX system, different symbols could be defined for the
     small-file and large-file programs.  For example:

        zips  :== $ dev:[dir.ALPHA]zip.exe      ! ZIPS = small-file Zip.
        zip*l :== $ dev:[dir.ALPHAL]zip.exe     ! ZIP[L] = large-file Zip.


For command help on any of the zip* utilities, simply enter
the name with no arguments.
